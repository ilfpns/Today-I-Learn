> 비트
> 

---

⇒ 자료형이 4비트라는 가정 하에 다음과 같은 기호를 사용할 수 있다

|  & | 두 비트가 모두 1일 때 1로 설정 | 1101 & 0110 => 0100 |
| --- | --- | --- |
| | | 두 비트 중 하나 이상이 1일 때 1로 설정 | 1000 | 0100 => 1100 |
| ^ | 두 비트가 다를 때 1로 설정 | 0101 ^ 1010 => 1111 |
| ~ | 비트를 반대로 설정 | ~0101 => 1010 |
| << | 비트를 왼쪽으로 이동, 범위를 벗어난 값은 무시 | 0101 => 1010 |
| >> | 비트를 오른쪽으로 이동, 범위를 벗어난 값은 무시 | 0101 => 0010 |

> **비트마스크**
> 

---

⇒ 특정 비트를 선택하거나 변경하는 데 사용되는 이진 숫자이다 

⇒ 이를 사용하여 특정 비트를 1로 설정하거나, 0으로 설정하거나, 클리어할 수 있다

**ㅤ**

```c
#define PIN 3
GPIO.out |= (1 << PIN);
GPIO.out &= ~(1 << PIN);
```

다음 코드를 보았을 때의 특징

- `|=` : 복합 대입 연산자로 OR연산을 진행하고 바로 사용함
- `(1 << PIN)` : 1은 이진수로 00000001이다 이걸 PIN만큼 밀어서 00001000으로 만들어 3번 PIN에 신호를 준다

**ㅤ**

- `&=` : AND연산을 진행하고 바로 사용함
- `~(1 << PIN)` : 위와 같이 1비틀를 밀고 ~를 사용하여 해당 비트를 0으로 만든다. 3번 PIN off

**ㅤ**

(다른 연산은 코드를 짤 때 더 공부)

> 비트 필드
> 

---

⇒ 인터럽트 등의 상태에서 1과 0만 표시한다, 1bit만 필요하다. 하지만 C에는 int형을 쓰게 되는데 그렇다면 31bits를 낭비하게 된다. 이에 사용하는 것이 비트 플래그이다

**ㅤ**

- 구조체 안에서만 생성 가능하다
- unsigned int 로 선언해야한다

**ㅤ**

```c
typedef struct {
    uint8_t LED1 : 1;  // 0번째 비트
    uint8_t LED2 : 1;  // 1번째 비트
    uint8_t LED3 : 1;  // 2번째 비트
    uint8_t LED4 : 1;  // 3번째 비트
    uint8_t RES  : 4;  // 나머지 비트 (예약)
} LED_CTRL_t;

volatile LED_CTRL_t led_ctrl = {0, 0, 0, 0, 0};
```

다음과 같은 코드에서

⇒ 구조체 하나로 LED 4개를 제어함

⇒ led_ctrl.LED1 = 1 과 같이 선언하면 1번 LED 제어

⇒ RES는 구조체 패딩을 맞추기 위해 예약만 걸어둔 상태이다

**ㅤ**

**장점**

- 가독성 : 비트마크는 무슨 비트가 뭘 한다는 건지 한 눈에 들어오지 않음, 비트 필드는 이름이 있음
- 유지보수 : 새 비트 추가, 비트 위치 조정이 있더라도 구조체를 찾아가 한 번 바꾸면 됨
- 메모리 : 8비트 안에 여러 상태 on/off를 넣을 수 있음
- 하드웨어 : 하드웨어 구조를 그대로 코드로 표현할 수 있다

**ㅤ**

```c
typedef struct {
    uint32_t EN   : 1;  // 0번째 비트
    uint32_t MODE : 1;  // 1번째 비트
    uint32_t FLAG : 1;  // 2번째 비트
    uint32_t RES  : 29; // 나머지 예약 비트
} PERIPH_CTRL_t;

volatile PERIPH_CTRL_t * const PERIPH_CTRL = (PERIPH_CTRL_t *)0x40021000;

PERIPH_CTRL->EN = 1;
```

다음 코드는 비트 필드가 조금 더 익숙해 졌을 때 다시 보자

**ㅤ**
