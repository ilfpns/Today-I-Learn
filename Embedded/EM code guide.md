> **기본 원칙**
> 

---

- Unsigned 타입 적극 사용 : 오버플로 방지, 메모리 효율
- volatile 키워드 정확히 사용 : 레지스터나 공유 변수에 필수
- 비트 연산 사용 : 메모리 절약, 빠른 상태 제어 가능
- 구조체 활용 : 관련 데이터를 묶어 코드 가독성과 유지보수
- 컴포넌트 분리 : 기능별로 나누면 수정, 유비보수 용이

**ㅤ**

> **함수 최적화 전략**
> 

---

⇒ 인라인 함수

- 함수 호출 제거 → 빠름
- 코드 크기 증가 가능성 있음

**ㅤ**

⇒ ABI 최적화 함수

- 호출 방식 유지 + 레지스터 인자 빠름
- 일부 아키텍쳐에서만 효과

**ㅤ**

> **루프 최적화**
> 

---

⇒ 루프 언롤링 

- 반복 횟수 줄이기 위해 루프 분문 복사
- 분기 명령 중여 속도 향상
- 코드 크기 증가

**ㅤ**

⇒ 불변 코드 분리

- 루프 내에서 반복 계산되는 상수/함수 → 루프 밖으로 이동

**ㅤ**

> **Switch**
> 

---

- Case가 연속적이면 → 컴파일러가 jump table 생성 → 성능 매우 좋음
- Case가 비연속적이면 → if-else로 처리 → 느림

**ㅤ**

> **GoTo**
> 

---

- 제한적 GoTo 사용 ⇒ 깊은 중첩 탈출 시 코드 간결화

**ㅤ**

사용하지 않을 때 스파게티 코드가 생길 수 있음

⇒ 스파게티 코드는 코드가 꼬여서 읽기 어렵고, 수정하기 힘든 구조이다

**ㅤ**

> **메모리**
> 

---

- 전역 데이터

→ const로 선언 (Rom에 배치)

- 스택

→ 크기 측정 + 재조정, 지역 배열 최소화

- 힙

→ malloc/new 제한, 대신 정적 할당

→ 메모리 풀 방식 사용 (고정 크기의 메모리 블록을 미리 확보해놓고, 필요할 때 할당/반납하는 방식)

- RTOS

→ 태스크별 스택 측정, ISR 스택 분리

**ㅤ**

> **구조체**
> 

---

| 항목 | 개별 인자 (int a, int b) | 구조체 포인터 (`T* t`) |
| --- | --- | --- |
| **함수 호출 시 인자 수** | 많아지면 성능 저하 (레지스터 → 스택) | 항상 1개 (포인터 하나) |
| **ABI 기준 효율** | ARM 기준 **4개 이하면 빠름** | 구조체가 크면 **포인터가 더 빠름** |
| **가독성/유지보수** | 여러 파라미터가 늘어지면 복잡 | 관련 데이터 그룹화로 **가독성 좋음** |
| **확장성** | 인자 추가 시 함수 시그니처 변경 필요 | 구조체 멤버만 추가하면 됨 |
| **코드 크기** | 함수 인라인 시 코드 증가 가능 | 포인터 접근은 다소 느릴 수 있음 |
| **RAM 사용** | 값 전달 시 복사 (특히 구조체면 비효율) | 포인터는 **주소만 전달**하여 효율적 |

```c
typedef struct {
    int x;
    int y;
    int z;
} Vector;

void normalize(Vector* v)
```
