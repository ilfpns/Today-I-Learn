> **사용처**
> 

---

⇒ 고속 메모리 연결

- 플래시 메모리 : EEPROM, NAND, FLAS, SD카드

⇒ 고속 센서 변환기

- ADC/DAC 칩 : IMU(가속도, 자이로), 터치스크린, 컨트롤러
- 데이터 양이 많고, 빠른 응답이 필요할 때 SPI를 사용한다.

⇒ 디스플레이 구동

- TFT LCD, OLED, e-Paper
- 화면 데이터 전송은 수백 KB 이상으로 I2C보다 SPI가 훨씬 빠르다.

⇒ 무선 통신 모듈

- Wi-Fi, BLE, RF
- 고속 데이터 송수신 필요, SPI로 MCU와 연결한다.

⇒ 오디오/비디오

- 오디오 Codec, DAC 칩
- 스트리밍 오디오 데이터 전송을 하는데 사용한다.

> **SPI 장점**
> 

---

⇒ 데이터 양이 많은 경우

- SPI : 연속 스트리밍, 대용량에 최적 → SD카드, 플래시, 오디오 전송
- I2C : 주소, ACK 오버헤드 커짐  → 속도가 느려져 대량 전송에 벙목
- UART :Start/Stop 오버헤드 누적, 속도 제한 → 로그 수준 이상은 비효율

⇒ 속도가 중요한 경우

- SPI : 클럭 동기 + 풀 듀플렉스 → 매우 빠름
- I2C : 100kHz ~ 1MHz → 속도 한계 때문에 SPI에 밀림
- UART : 비동기, Start/Stop bit → 전송 효율이 낮아 느림

⇒ 통신 안정성이 중요한 경우

- SPI : 클럭 동기식 → 데이터 싱크 안정, 노이즈에도 강함
- I2C : 오픈헤드 구조 + 풀업 저항 → 잡음에 취약
- UART : 비동기라 고속 시 클럭 미스매치 → 에러 확률이 높음

⇒ 양방향(풀 듀플렉스) 통신 필요

- SPI : 송수신 동시 가능
- I2C : 단일 SDA라인, 반이중이라 동시 전송 불가
- UART : 이론상 전이중이 가능하지만 속도가 낮아 실시간 대량 송신에 불리하다

⇒ 실시간성이 중요한 경우

- SPI : 클럭 기반, 바로 전송/응답 가능 →RF 모듈, 오디어 Codec에 적합
- I2C : ACK/NACK 대기 때문에 지연 → 실시간 처리에 부적합
- UART : 비동기 + 프레임 단위라 실시간 스트리밍에 한계

> **SPI 연결**
> 

---

```c
#define PIN_NUM_MISO 19
#define PIN_NUM_MOSI 23
#define PIN_NUM_CLK  18
#define PIN_NUM_CS   5

void app_main(void) {
	spi_bus_config_t buscfg = {
		 .mosi_io_num = PIN_NUM_MOSI,
     .miso_io_num = PIN_NUM_MISO,
     .sclk_io_num = PIN_NUM_CLK,
     .quadwp_io_num = -1,
     .quadhd_io_num = -1,
	};
	
	spi_bus_initialize(SPI2_HOST, &buscfg, SPI_DMA_CH_AUTO);
	
	spi_device_interface_config_t devcfg = {
        .clock_speed_hz = 1 * 1000 * 1000,   // 1 MHz
        .mode = 0,                           // SPI 모드0
        .spics_io_num = PIN_NUM_CS,          // CS 핀
        .queue_size = 1,                     // 트랜잭션 큐 크기
    };
    
    spi_device_handle_t spi;
    spi_bus_add_device(SPI2_HOST, &devcfg, &spi);
}
```

- `spi_bus_config_t`
    - MOSI/MISO/SCLK 핀 지정 (초기화 핀맵)
    
- `spi_bus_initialize`
    - `host` : 어떤 SPI 컨트롤러 (호스트) 를 쓸지 결정
        
        ⇒ SPI2_HOST, SPI3_HOST 사용 (SPI1_HOST는 내부적 플래시에서 쓰이기에 일반적으로 안 씀)
        
    - `bus_config` : 핀 맵 설정 구조체 전달
    - `dma_chan` : DMA 채널 지정
        
        ⇒ `SPI_DMA_CH_AUTO` : 자동 할당
        

- `spi_device_interface_config_t`
    - 클럭, 모드, CS 핀 지정

- `spi_bus_add_device`
    - `host` : 앞에서 초기화한 SPI 버스 (SPI2_HOST)
    - `dev_config` : device 설정 구조체 전달
    - `handle` : spi_device_handle_t 타입 포인터 핸들, 성공시 핸들로 디바이스 제어
        
        ⇒ `spi_device_handle_t spi`  다음과 같이 spi를 핸들로 생성
        
        ⇒ 다른 device는 CS 핀만 바꾸면 됨
