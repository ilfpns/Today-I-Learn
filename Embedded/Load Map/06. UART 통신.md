> **사용처**
> 

---

⇒ 디버깅 • 로그 • 콘솔 

- 개발중 printf, 쉘 (Power Shell)

⇒ 펌웨어 다운로드 • 부트로더 

- ESP계열 STM32등 시리얼 부트

⇒ 통신 모듈 

- LTE / WI-FI 등

⇒ 거리 • 라이다 • 센서 

- Uart Lidar, 일부 RFID / 지문 센서

⇒ 프린터 

- 소형 프린터 / 바코드 스캐너

> **장점**
> 

---

⇒ PC • 사람 친화적

- UART : USB-UART 꽂으면 곧바로 COM/tty로 잡힌다.
- UART : 로깅, 콘솔, 간단 명령 등 테스트가 가장 빠르다.
- I2C/SPI : PC직결이 번거롭고 툴도 제한적이다.

⇒ 단순한 (1 : 1) 링크

- UART : 바이트 스트림만 주고받으면 된다.
- UART : 주소 / CS / 레지스터 트랜잭션 개념이 없어 구현이 쉽고, 디버그가 빠르다.
- I2C : 주소 / ACK / 풀업 등 고려사항이 많다.
- SPI : CS관리 / 모드 등 고려사항이 많다.

⇒ 장거리 노이즈 환경에 강하다

- UART : 트랜시버를 물리면 수십 ~ 수백 m 산업 배선에도 적합하다.
- UART : 표준 시리얼 라인으로 연동이 쉽다.
- I2C/SPI : 보드 내부나 짧은 거리 위주로 사용한다.

⇒ 프로토콜/모듈 생태계가 풍부하다

- UART : AT모뎀 등에서 그냥 UART를 꽂고 쓰는 모듈의 수가 압도적이다.

> **연결**
> 

---

```c
#define UARTP   UART_NUM_1
#define TXD     17
#define RXD     16
#define BUF_SZ  1024

uart_config_t cfg = {
        .baud_rate = 115200,                 
        .data_bits = UART_DATA_8_BITS,
        .parity    = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,
        .source_clk = UART_SCLK_APB,
    };
 
int app_main(void) {
	uart_param_config(UARTP, &cfg);
	uart_set_pin(UARTP, TXD, RXD, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);
	uart_driver_install(UARTP, BUF_SZ, 0, 0, NULL, 0);
}
```

- 기본적 UART를 연결하고 driver를 설치하는 과정이다.
- `uart_config_t` 는 uart의 설정을 담는 구조체 자료형이다.
    - 보통 어떤 기능에 대한 설정을 할 때
        1. 구현하고자 하는 기능 이름 파악 (uart → uart_config)
        2. 구조체 이므로 _t를 붙히면 된다 (uart_config → uart_config_t)

- `uart_param_config` ⇒ 해당 UART 포트의 통신 포맷 / 쿨럭 설정 적용한다.
    - 구조체 값을 넘겨 설정을 시작한다
    
- `uart_set_pin` ⇒ 해당 UART 포트의 TX/RX/RTS/CTS를 어떤 GPIO에 배치할지 정한다.
    - ESP32는 GPIO 매트릭스로 거의 모든 핀으로 라우팅 가능

- `uart_driver_install` ⇒ UART 드라이버를 실제로 설치하여 링버퍼 담당, 이벤트 큐 생성 등등을 처리한다.
