> **I2C**
> 

---

### 사용처

- 환경 센서 : 온도 / 습도 / 기압 / 조도 / 가스 센서 등
- IMU 센서 : 가속도계 / 자이로 등
- 자기 센서  : 전자 나침반
- 터치 센서 : Capacitive Touch Controller

⇒ 임베디드 프로젝트의 센서 값은 I2C가 대부분 해결한다.

- 소형 OLED
- LCD 문자 디스플레이
- 저전력 E-ink 디스플레이

⇒ 작은 화면을 사용하면 I2C 디스플레이가 간단하다.

- EEPROM
- RTC : 실시간 시계
- FRAM : 고속 비휘발성 메모리

⇒ 설정값 저장, 시계 모듈 추가등에 I2C가 유용하다.

- IO Expander : GPIO 확장
- PWM
- ADC / DAC

⇒ MCU핀이 모자라거나 고정밀 ADC가 필요할 때 I2C가 유용하다.

- PMIC
- 배터리 게이지 칩

⇒ IoT 기기 / 모바일 디바이스에서 I2C를 사용한다.

### I2C의 장점

1. **단순한 배선**
    - I2C : SDA + SCL 두 가닥으로 배선이 끝남
    - SPI : 최소 4 가닥 필요 (MOSI, MISO, SCK, CS) + 슬레이브마다 CS핀 추가
    - UART : TX/RX만 있으면 충분하지만, 장치가 2개만 연결 가능 (1 : 1)
    
    ⇒ 핀/배선 적게 사용하며 여려 장치를 연결할 수 있음 → 보드 설계 / 배선이 단순해짐
    
2. **멀티 슬레이브 지원**
    - I2C : 주소 체계가 있어, 한 버스에 수십 개의 장치를 붙일 수 있다.
    - SPI : 슬레이브마다 CS핀을 따로 써야 한다, 이는 핀 낭비로 이어진다.
    - UART : 사실상 (1 : 1) 이다.
    
    ⇒ 센서를 여러 개 붙일 땐 12C가 훨씬 편리
    

1. **속도 / 전력 밸런스**
    - I2C : 수백 kHz ~ 몇 MHz → 센서에 데이터를 주기엔 충분하다.
    - SPI : 훨씬 빠르다 (수십 MHz) → 고속 ADC, LCD, SD카드 등에 사용된다.
    - UART : 속도는 kHz ~ Mbps 로 가능하지만 (1 : 1) 만 되고 멀티센서에 부적합하다.
    
    ⇒ 센서 읽기와 같은 빠르지 않아도 되는 경우 I2C로 충분하다.
    
    ⇒ 저전력 모드를 지원한다, 배터리 구동 IoT에 적합하다.
    

### 연결

```c
#include "driver/i2c_master.h"

#define SDA 21
#define SCL 22

static i2c_master_bus_handle_t bus;
static i2c_master_dev_handle_t dev;

void i2c_connect(void) {
	i2c_master_bus_config_t i2c_master_bus_config = {
		.i2c_port = I2C_NUM_0, .sda_io_num = SDA, .scl_io_num = SCL,
    .clk_source = I2C_CLK_SRC_DEFAULT, .glitch_ignore_cnt = 7,
	};
	
	i2c_new_master_bus(&i2c_master_bus_config, &bus);
	
	i2c_device_config_t i2c_device_config = {
		.dev_addr_length = I2C_ADDR_BIT_LEN_7,
    .device_address  = 0x68,  
    .scl_speed_hz    = 400000,
	};
	
	i2c_master_attach_device(bus, &i2c_device_config, &dev);
}
```

- **버스 1개를 제작하고, 그 버스에 디바이스를 1개 붙이는 코드이다.**

- **`static` 으로 선언된 변수**
    - 파일 전역 변수로 변수를 만든 것이다.
        1. 수명 : 프로그램 전체 동안 유지 
        2. 가시성 : 선언된 소스 파일 내부에서만 보임
        3. 기능 : 새로 정의될 디바이스 or 마스터 버스의 핸들을 저장할 공간
        
- **I2C는 7/10비트 슬레이브 주소로 기기를 구분**

- **새로운 Master 버스 생성**
    - `i2c_new_master_bus(&i2c_master_bus_config, &bus)`
        1. 인자 01 : SDA/SCL 핀, 소스, 글치필터 등 버스에 설정
        2. 인자 02 : 결과를 저장할 버스 핸들
        3. 결과 : 새로운 I2C 마스터 버스가 생김
    - `i2c_master_attach_device(bus, &i2c_device_config, &dev)`
        1. 인자 01 : 이미 생성된 마스터 버스 핸들 (새 디바이스가 연결될 버스 지정)
        2. 인자 02 : 슬레이브 디바이스 설정
        3. 인자 03 : 결과를 저장할 디바이스 핸들

### 레거시 I2C, 신 I2C

- **버전 v4.x : legacy I2C**
- **버전 v5.x : new I2C**

버전과 함께 헤더, 초기화, 트랜잭션 등 많은 문법이 달라진다.

현재는 v5.x를 추천한다

```c
#include "driver/i2c.h" // -> legacy
#include "driver/i2c_master.h" // -> new
```
