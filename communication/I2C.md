# Inter - Intergrated Circuit

→ IC 사이 통신 링크를 제공하는 양방향 2와이어 직렬 버스 이다

- I2C 통신은 2개의 선을 이용하는 통신 방식
- 하나의 마스터와 여러개의 슬레이브 기기가 몰려 통신이 가능
- 클럭 신호를 사용하는 동기식 통신 방법이라 시간에 자유로움
- 여러 선을 사용할 필요 없이 2개의 선으로 충분하다

- 메모리(레지스터)의 주소를 지정함
- 데이터(센서, etc..)등에서 읽기/쓰기 기능을 수행함

![image](https://github.com/user-attachments/assets/a783e7a3-aad2-41d2-bc38-4ca6b8c332e0)

첫번째 가닥은 SDA 선이다 

→ 데이터를 주고 받기 위한 선

두번째 가닥은 SCL 선이다

→ 타이밍을 동기화 하기 위한 클럭 선이다

→ 시리얼 통신이 맞지 않아도 된다 (9600, 115,200)

![image](https://github.com/user-attachments/assets/0fa1f957-4c18-45ce-ab09-0b77b2db1f6d)

SDA선에서 신호를 주어 통신을 START/STOP 할 수 있다.
---

### SCL/SDA

- SCL/SDA : 1 (HIGH)
- SCL/SDA 통신이 시작된 후 : 클럭 라인보다 먼저 0 (LOW)로 변환
- 통신 종료 : SCL → SDA 순서로 0에서 1로 변환

### I2C slave

⇒ I2C는 기본적으로 주소값으로 각 모듈을 구분하기에 (1 : N) 연결이 가능하다

⇒ Slave 주소 값은 보통 7bits 값을 가진다 (이론상 127개의 Slave 연결 가능)

---

### **START/STOP 조건으로 메시지를 구분**

- **START**: SDA가 HIGH→LOW 전이될 때 SCL이 HIGH → "통신 시작" 신호
- **STOP**: SDA가 LOW→HIGH 전이될 때 SCL이 HIGH → "통신 종료" 신호

### 주소 + R/W 비트 → ACK

1. 마스터가 슬레이브에게 7비트 주소 + 읽기 or 쓰기 비트 전송
2. 9번째 클록에서 슬레이브가 SDA를 LOW로 당기면 ACK응답
3. 데이터 바이트 전송 후 다시 ACK/NAK 응답

- 마스터는 슬레이브에게 이러한 방식으로 전송한다

```scss
“0x3C 주소를 가진 너! 데이터를 읽을 건지(1) 쓸 건지(0) 알려줄게!”
```

- 이때 보내는1바이트의 구조는 다음과 같다

```css
[7비트 주소] + [1비트 R/W]
```

- 예:
    - `0x3C` = `0111100`
    - 쓰기(write): `01111000`
    - 읽기(read): `01111001`

- 이렇게 R/W중 하나를 선택하고 다음 클록을 생성함(9번째)
    
    → 슬레이브는 SDA를 0으로 낮춰서(LOW) "나 여기 있어요!"라고 응답함 → ACK
    

### 전반적인 구동 체계

```scss
[START]
→ [주소 7비트 + R/W(1)]
→ [슬레이브 ACK]
→ [슬레이브가 데이터 8비트 전송]
→ [마스터 ACK]
→ [슬레이브가 데이터 8비트 전송]
→ [마스터 NAK] (더 이상 안 받을 경우)
→ [STOP]
```

---

### **클록 스트레칭 (Clock Stretching)**

- 슬레이브가 데이터 준비가 안 됐을 경우 **SCL을 LOW 상태로 유지**, 마스터가 기다리게 할 수 있음
- 저속 장치를 배려하기 위한 흐름 제어 기능

| 요소 | 의미 |
| --- | --- |
| SDA | 실제 데이터 선 (데이터 주고받는 선) |
| SCL | 박자(클록) 맞추는 선 |
| START/STOP | 통신의 시작과 끝을 알리는 신호 |
| 주소 | 어떤 장치와 이야기할지 지정 |
| R/W | 읽을지, 쓸지 선택 |
| ACK | 메시지 전달 확인 신호 |

---

### 성능

1. I2C
2. UART
3. SPI 

SPI가 I2C보다 빠르지만 

이점이 부족하다.
