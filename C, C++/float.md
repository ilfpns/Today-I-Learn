> **float의 본질**
> 

---

⇒ float = IEEE 754 32비트 부동소수점

```css
[부호 1bit][지수 8bit][가수 23bit]
```

- 표현범위  ⇒

$$
±3.4×10⁻³⁸ ~ ±3.4×10³⁸
$$

- 정밀도 : 약 6 ~ 7 자리
- 0.1, 0.01 같은 값은 정확히 표현 불가

**ㅤ**

> **Floating Point Unit**
> 

---

⇒ 하드웨어로 덧셈/곱셈을 병렬처리 → 정수연산급 속도

**ㅤ**

| 상황 | 추천 자료형 | 이유 |
| --- | --- | --- |
| 센서 보정, 필터, IMU | `float` | 연산 간단, 오차 감내 가능 |
| PID 제어, 제어루프 | `float` (FPU 있을 때만) | 빠른 계산 & 실시간성 |
| FPU 없음, 연산 단순 | `fixed-point (Q15, Q31)` | 정밀도 유지, 속도 ↑ |
| 데이터 통신, 로깅 | `int16`, `int32` | 변환비용 ↓, 안정성 ↑ |

**fixed-point 대안**

- float 느릴 때 자주 사용되는 기법
    
    예 : Q15 → 1비트 부호 + 15비트 소수
    

```c
int16_t q15 = (int16_t)(x * 32768);
float y = q15 / 32768.0f;
```

### 결론

⇒ 임베디드에서 float는 정확한 속도와 메모리를 절충한 근사값 도구이다. FPU가 있을 때만 쓰고, 없을 땐 fixed-point가 정석이다
